
backwardSearchSingleLimit :: Int
backwardSearchSingleLimit = 8

backwardSearchGlobalLimit :: Int
backwardSearchGlobalLimit = 30

--runs a backward search from each halting state to see if it can reach a contradiction
--if we show that all ways to halt don't have paths leading into them from valid tapes
--then the halt state will never be reached
--of course no such procedure can be complete, so we put a finite depth on the search and
--give up after a while
backwardSearch :: Turing -> Maybe HaltProof
backwardSearch (Turing n trans) = recurse 0 $ fromList $ (, Min 0) <$> (initState <$> unusedEdges) where
  unusedEdges :: [Edge]
  unusedEdges = NE.filter (\e -> (at e . _Nothing) `has` trans) $ uniEdge n
  initState :: Edge -> (Phase,Tape)
  initState (p, b) = (p, Tape [] b [])
  loop :: Int -> ((Phase, Tape), Int) -> MonoidalMap (Phase, Tape) (Min Int) -> Maybe HaltProof
  loop globalSteps _ _ | globalSteps > backwardSearchGlobalLimit = Nothing
  loop _ (_, localSteps) _ | localSteps > backwardSearchSingleLimit = Nothing
  loop globalSteps (tape, localSteps) rest
    = case fromList $ (,Min $ localSteps+1) <$> backSteps tape of
      Empty -> recurse globalSteps rest
      possibilities -> recurse (globalSteps + 1) (possibilities <> rest)
  recurse :: Int -> MonoidalMap (Phase,Tape) (Min Int) -> Maybe HaltProof
  recurse _globalSteps Empty = Just $ BackwardSearch
  recurse globalSteps (deleteFindMin -> (f, rest)) = loop globalSteps (second getMin f) rest

  transList = assocs trans
  candidateTrans :: Phase -> [(Edge, Trans)]
  candidateTrans p = filter ((== Just p) . getPhase . snd) transList
  --given a tape, returns all tapes that could result in the given tape
  backSteps :: (Phase,Tape) -> [(Phase,Tape)]
  backSteps (p, t) = mapMaybe (backStep (p,t)) $ candidateTrans p

  --precondition: the phase given and the getPhase of the Trans are the same
  backStep :: (Phase,Tape) -> (Edge,Trans) -> Maybe (Phase, Tape)
  --if the trans makes us step left, we care about what is to the right
  backStep (_p, Tape ls point []) ((inP, inB), (Step _p' _outB L))
    = Just $ (inP, Tape (point:ls) inB [])
  backStep (_p, Tape ls point (r:rs)) ((inP, inB), (Step _p' outB L))
    = guard (r == outB) >> (Just (inP, Tape (point:ls) inB rs))
  --conversely if the trans makes us step right, we were previously on the left
  backStep (_p, Tape [] point rs) ((inP, inB), (Step _p' _outB R))
    = Just $ (inP, Tape [] inB (point:rs))
  backStep (_p, Tape (l:ls) point rs) ((inP, inB), (Step _p' outB R))
    = guard (l == outB) >> (Just (inP, Tape ls inB (point:rs)))
  backStep _ (_, Halt) = Nothing
